<h2>Settings</h2>

<p>All modifications to the settings only get permanently stored, when the <b>&quot;Save&quot;</b> button is used!</p>

<h5>Setting the time</h5>
<p>After a new detected router can get accessed, the time of the router will get set to the time, that is set on the router with the Kickstarter container.</p>

<h5>Initial login</h5>
<p>Setting the initial login credentials are not necessary when the devices are in default settings. If the devices are not in default settings, these credentials are used.
   If login with no credentials or the credentials given here are both failing, the credentials from the aftercare phase (see below) will be used.</p>

<h5>Uploading Firmware</h5>
<p>All detected routers will get optionally updated to the configured firmware.
    Updating the firmware is disabled by selcting &quot;---&quot;.
    The firmware must be available on the container as an autoupdate full image (autoupdate-x.y-full.tar).</p>

<p>Optionally Kickstarter can periodically check for new firmware.
    For that the URI for the firmware check must point to an Auto-Update server, that offers a list.txt file with the new firmware.
    The new firmware can automatically get used as the &quot;latest&quot; firmware availlable to flash.</p>

<h5>Updating more (e.g. containers, profiles, licenses)</h5>
<p>More uploads can be configured here, that will be uploaded to the detected device.
    Update packets will get uploaded and processed, as the MANIFEST of the update packet defines.
    Pure ASCII files also can get uploaded and stored in &quot;Profiles&quot;
    Optionally they can get activated immediatelly after uploading them, so the running profile gets modified.</p>

<h5>Upload and apply CSV config table</h5>
<p>Optionally a CSV (Comma Separated Values) file can be used.
    It can be used to execute CLI commands with arguments, that depend on the serial number of the device.
    <table border="1">
        <tr><td></td>             <td>ALL</td>        <td>Serial 1</td>   <td>Serial 2</td>   <td>Serial 3</td>   <td> ... </td> </tr>
        <tr><td>CLI command 1</td><td></td>           <td></td>           <td></td>           <td></td>           <td></td>      </tr>
        <tr><td>CLI command 2</td><td>Argument X</td> <td></td>           <td></td>           <td></td>           <td></td>      </tr>
        <tr><td>CLI command 3</td><td>Argument Y</td> <td></td>           <td></td>           <td></td>           <td></td>      </tr>
        <tr><td>CLI command 4</td><td></td>           <td>Argument A</td> <td>Argument B</td> <td>Argument C</td> <td></td>      </tr>
        <tr><td>CLI command 5</td><td></td>           <td>Argument a</td> <td>Argument b</td> <td>Argument c</td> <td></td>      </tr>
        <tr><td>CLI command 6</td><td>Argument Z</td> <td></td>           <td></td>           <td></td>           <td></td>      </tr>

    </table>
</p>

<p>All CLI commands will get processed from top to bottom.
    A CLI command can be a complete command, like with &quot;CLI command 1&quot; of the example table.
    This will remove all existing routes of any detected device</p>

<p>The CLI commands can contain variables, which will compose the final CLI command, that is sent to the individual device.</p>
<ul>
<li><p>No variable at all:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>routing.static_routes.route.delete=all</code></p>
</li>

<li><p>Variable <b>{VALUE_FROM_ALL}</b></p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>routing.static_routes.route.delete={VALUE_FROM_ALL}</code></p>
<p>where the text &quot;all&quot; should be in the column &quot;all&quot;.</p>
<p>This would be the same result than with no variable above.</p>
</li>

<li><p>Variable <b>{VALUE_FROM_SN}</b></p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>interfaces.net1.ip_address[1].ip_address={VALUE_FROM_SN}</code></p>
<p>where text like &quot;192.168.1.100&quot; should be in the coloumn of the devices serial number.</p>
</li>

<p>Often the last CLI command would be the text to activate the modified profile: &quot;administration.profiles.activate&quot;</p>
</ul>

<h5>Register device at iRM (icom Router Management)</h5>
<p>Optionally every device can be registered at iRM.
    In that case the created ConnectionProfile in iRM will be downloaded and uploaded to the device.</p>

<p>Access to the REST API of iRM will require an API token, that is created in iRM.</p>

<p>It's also required to configure a group, in which all newly registrated devices will appear.
    It might be reasonable to define a new group for all the new devices, so they can get pushed to their final group in iRM, after there happend more configuration within iRM.</p>

<pre>
curl -k -X 'POST' 'https://192.168.1.1/api/v2_0/auth/login' \
    -H 'accept: application/json' \
    -H 'Content-Type: application/json' \
    -d '{ "username": "insys", "password": "icom" }'
</pre>

<h5>Aftercare: HTTP(S) requests to the finished devices</h5>
<p>After a device ran through all the phases described above the optional aftercare phase will query information from the deivces.
This info gets stored in a file, so the user has documentation about the processed devices.</p>

<p>Kickstarter will send HTTPS requests to the devices, which most likely have been configured in the above phases, so a user name and a password have to be known to Kickstarter.</p>
<p>The answers to the HTTPS requests will be stored in a log file, the content is JSON. Additionally the info is stored in a CSV file. The given delimiter character is used to separate the columns in the CSV file.</p>

<p>Every request sent to the device is defined by:</p>
<ul>
    <li><b>CSV column name:</b>	The response of the requests is stored in column of the CSV file with this header name.</li>
    <li><b>Request URI:</b> This string will be appended to he IPv6 address of the queried device and sent to the device.</li>
    <li><b>JSONPATH to data:</b> The JSONPATH defines the path within the JSON formated answer of the request, that leads to the data, that should be stored in the log and CSV file.</li>
    <li><b>Expected result of request:</b> Optionally the data of the answer can be compared to this defined string in order to check, that the above phases were actually successful.</li>
</ul>

The necessary request URI can be found by using a tool like <a href="https://www.usebruno.com/">bruno</a> or a online service like <a href="https://editor.swagger.io/">editor.swagger.io</a>. Import the <a href="https://192.168.1.1/cgi_c_download_rest_docu">REST-API documentation</a> into the chosen tool and find out the necessary URI and the returned data.</p>

<p>

<pre>
curl -k -X 'POST' 'https://192.168.1.1/api/v2_0/operation' \
    -H 'accept: */*' \
    -H 'Authorization: Bearer eyJhbGciO ... R5cCIX3a8' \
    -H 'Content-Type: application/json' \
    -d '{
            "method": "manual_action",
            "params": {
                "type": "sms",
                "options": {
                    "modem": "lte2",
                    "recipient": "012345678",
                    "text": "This is SMS text"
                }
            }
        }'
</pre>
